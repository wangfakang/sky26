{
  "name": "Sky26",
  "tagline": "one request and all worker accept",
  "body": "nginx单个请求让多个worker同时接受处理：\r\n\r\n有个开源的patch[per-worker-listener](https://github.com/arut/nginx-patches/blob/master/per-worker-listener),这个patch可以使得每一个worker进程都可以进行监听端口；\r\n\r\n其实单个请求多个worker同时执行，可以使用子请求（ngx.location.capture）+反向代理(proxy_pass)来做（目前来看是最简单的一种方式）;\r\n\r\n\r\n\r\n简单列子：  \r\n\r\n``` c\r\n\r\nworker_processess auto;\r\n\r\nevents {\r\n    worker_connections  1024;\r\n    accept_mutex off; #importent\r\n}\r\n\r\n\r\nhttp {\r\n\r\n    server {\r\n        listen 80;\r\n        listen       8010 per_worker; #importent\r\n        server_name  localhost;\r\n        \r\n        #ngx.location.capture只可以内部location跳转\r\n        location /muti {\r\n           content_by_lua '  \r\n             local host = \"127.0.0.1\"\r\n             local port = 8010\r\n             local count = ngx.worker.count()\r\n             for i = 1 , count  do\r\n                 local res = ngx.location.capture(\"/internal?\" .. \"host=\" .. host .. \"&port=\" .. port)\r\n                 if res then\r\n                     ngx.say(\"status: \", res.status)\r\n                     ngx.say(\"body:\")\r\n                     ngx.print(res.body)\r\n                 end\r\n                 port = port + 1\r\n            end\r\n         ';\r\n        }\r\n\r\n        #利用proxy_pass进行发送http请求\r\n        location /internal {\r\n            proxy_pass http://$arg_host:$arg_port/showinfo;\r\n        }\r\n\r\n        #每个worker将会执行此location\r\n        location /showinfo {\r\n            content_by_lua '\r\n                ngx.say(\"pid: \" .. ngx.var.pid .. \", port: \" .. ngx.var.server_port .. \"\\t\")\r\n           ';\r\n        }\r\n\r\n    }\r\n}\r\n\r\n```  \r\n\r\n\r\n请求：     \r\ncurl localhost:80/muti \r\n\r\n将会输出：  \r\n\r\n```c\r\nstatus: 200\r\nbody:\r\npid: 4785, port: 8010    \r\nstatus: 200\r\nbody:\r\npid: 4786, port: 8011\t\r\nstatus: 200\r\nbody:\r\npid: 4787, port: 8012\t\r\nstatus: 200\r\nbody:\r\npid: 4788, port: 8013\t\r\n```\r\n\r\n从输出结果可以看到nginx的4个worker都执行了这个请求；  \r\n\r\n\r\n   其实此时就可以利用这个机制进行nginx内部worker之间的通信（其实nginx内部是通过channel实现的worker之间的通信）\r\n其实也可以利用这个机制实现nginx集群的通信；\r\n\r\n```\r\n\r\n\r\n               M1                      M2\r\n\r\n          w1   w2   w3           w1    w2    w3\r\n  \r\n                     nginx cluester\r\n                     \r\n```                     \r\n\r\n                   \r\n如上图所示，其中M1与M2是nginx cluster中的两个节点，M1与M2之间的worker之间可以使用http进行通讯；\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}